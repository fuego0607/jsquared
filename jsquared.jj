/* JavaCC input file for a simple imperative language. */
/* JSquared by Jose Angulo and Jeremy Hofer */
PARSER_BEGIN(JSquared)

import java.io.*;

class JSquared {
	public static void main(String[] args) throws ParseException, TokenMgrError {
		if (args.length > 0) {
			try {
				JSquared scan = new JSquared(new FileInputStream(args[0]));
				Node tree = scan.Program();
				printAST(tree);
			} catch (FileNotFoundException ex) {
				System.out.println("File "+args[0]+" not found.");
			}
		} else {
			System.out.println("Must specify source code file name.");
		}
	}

	public static void printAST(Node node) {
		String label = node.getLabel();
		if(label.equals("INT") || label.equals("ID")) {
			System.out.println(node);
		} else {
			System.out.println(node);
			Node child = node.getChild();
			while(child != null) {
				printAST(child);
				child = node.getChild();
			}
		}

		return;
	}
}

PARSER_END(JSquared)

SKIP : { " " | "\t" | "\n" }
TOKEN : { <COMMENT : "//"(["a"-"z", "A"-"Z","0"-"9","_"," ","<",">","!","=","/","%","@","#",":","(",")","*",",","."])* >}
TOKEN : { <LPAREN : "("> }
TOKEN : { <RPAREN : ")"> }
TOKEN : { <DBLSTAR : "**"> }
TOKEN : { <SGLSTAR : "*"> }
TOKEN : { <INPUT : "<<" >}
TOKEN : { <OUTPUT : ">>" >}
TOKEN : { <ASSIGN : ":" > }
TOKEN : { <ADD : "+" > }
TOKEN : { <SUB : "-" > }
TOKEN : { <DIV : "/" > }
TOKEN : { <MOD : "%" > }
TOKEN : { <LESSEQ : "<=" > }
TOKEN : { <GREATEQ : ">=" > }
TOKEN : { <LESS : "<" > }
TOKEN : { <GREAT : ">" > }
TOKEN : { <NOTEQ : "!=" > }
TOKEN : { <EQ : "==" > }
TOKEN : { <INT : "0" | ["1"-"9"](["0"-"9"])* > }
TOKEN : { <ID : ["a"-"z", "A"-"Z"](["a"-"z", "A"-"Z","0"-"9","_"])* > }

void PrintTokens():
{
	Token t;
}
{
	(
		<LPAREN>  { System.out.println("LPAREN"); }
		|
		<RPAREN>  { System.out.println("RPAREN"); }
		|
		<DBLSTAR>  { System.out.println("DBLSTAR"); }
		|
		<SGLSTAR>  { System.out.println("SGLSTAR"); }
		|
		<INPUT>  { System.out.println("INPUT"); }
		|
		<OUTPUT>  { System.out.println("OUTPUT"); }
		|
		<ASSIGN>  { System.out.println("ASSIGN"); }
		|
		<ADD>  { System.out.println("ADD"); }
		|
		<SUB>  { System.out.println("SUB"); }
		|
		<DIV>  { System.out.println("DIV"); }
		|
		<MOD>  { System.out.println("MOD"); }
		|
		<LESSEQ>  { System.out.println("LESSEQ"); }
		|
		<GREATEQ>  { System.out.println("GREATEQ"); }
		|
		<LESS>  { System.out.println("LESS"); }
		|
		<GREAT>  { System.out.println("GREAT"); }
		|
		<NOTEQ>  { System.out.println("NOTEQ"); }
		|
		<EQ>  { System.out.println("EQ"); }
		|
		t = <INT>  { System.out.println("INT("+t.image+")"); }
		|
		t = <ID>   { System.out.println("ID("+t.image+")"); }
		|
		t = <COMMENT> { System.out.println("COMMENT("+t.image+")"); }
	)+
}

Node Program():
{
	Node n;
	Node child;
}
{
	{n = new Node("PROGRAM");}
	(
		child = Block() {n.addChild(child);}
	)+
	{return n;}
}

Node Base_Stmt():
{
	Node n;
}
{
	(
		n = Input()
		|
		n = Output()
		|
		n = Assign()
		|
		n = Cond()
		|
		n = While()
	)
	{return n;}
}

Node Input():
{
	Node n;
	Node child;
	Token t;
}
{
	<INPUT> {n = new Node("INPUT");}
	t = <ID> {n.addChild(new IDNode(t.image));}
	{return n;}
}

Node Output():
{
	Node n;
	Node child;
}
{
	<OUTPUT> {n = new Node("OUTPUT");}
	child = Logic_Exp() {n.addChild(child);}
	{return n;}
}

Node Assign():
{
	Node n;
	Node child;
	Token t;
}
{
	t = <ID> {child = new IDNode(t.image);}
	<ASSIGN> {n = new Node("ASSIGN"); n.addChild(child);}
	child = Logic_Exp() {n.addChild(child);}
	{return n;}
}

Node Cond():
{
	Node n;
	Node child;
}
{
	<SGLSTAR> {n = new Node("COND");}
	<LPAREN>
	child = Logic_Exp() {n.addChild(child);}
	<RPAREN>
	child = Block() {n.addChild(child);}
	(
		child = Block() {n.addChild(child);}
	)?
	{return n;}
}

Node While():
{
	Node n; //root of tree
	Node child; //
}
{
	<DBLSTAR> {n = new Node("WHILE");}
	<LPAREN>
	child = Logic_Exp() {n.addChild(child);}
	<RPAREN>
	child = Block() {n.addChild(child);}
	{return n;}
}

Node Block():
{
	Node n;
	Node child;
}
{
	<LPAREN> {n = new Node("BLOCK");}
	(
		child = Base_Stmt() {n.addChild(child);}
		|
		(
			<LPAREN>
			child = Base_Stmt() {n.addChild(child);}
			<RPAREN>
		)*
	)
	<RPAREN>
	{return n;}
}

Node Logic_Exp():
{
	Node n;
	Node child;
}
{
	child = Math_Exp() {n = new Node("LOGIC_EXP"); n.addChild(child);}
	(
		(
			<LESS> {child = new Node("LESS");}
			|
			<GREAT> {child = new Node("GREAT");}
			|
			<LESSEQ> {child = new Node("LESSEQ");}
			|
			<GREATEQ> {child = new Node("GREATEQ");}
			|
			<NOTEQ> {child = new Node("NOTEQ");}
			|
			<EQ> {child = new Node("EQ");}
		) 
		{n.addChild(child);}
		child = Math_Exp() {n.addChild(child);}
	)?
	{return n;}
}

Node Math_Exp():
{
	Node n;
	Node child;
}
{
	child = Math_Term() {n = new Node("MATH_EXP"); n.addChild(child);}
	(
		(
			<ADD> {child = new Node("ADD");}
			|
			<SUB> {child = new Node("SUB");}
		)
		{n.addChild(child);}
		child = Math_Term() {n.addChild(child);}
	)*
	{return n;}
}

Node Math_Term():
{
	Node n;
	Node child;
}
{
	child = Math_Factor() {n = new Node("MATH_TERM"); n.addChild(child);}
	(
		(
			<SGLSTAR> {child = new Node("MUL");}
			|
			<DIV> {child = new Node("DIV");}
			|
			<MOD> {child = new Node("MOD");}
		)
		{n.addChild(child);}
		child = Math_Factor() {n.addChild(child);}
	)*
	{return n;}
}

Node Math_Factor():
{
	Node n;
	Token t;
}
{
	(
		t = <ID> {n = new IDNode(t.image);}
		|
		t = <INT> {n = new INTNode(t.image);}
		|
		<LPAREN>
		n = Math_Exp()
		<RPAREN>
	)
	{return n;}
}